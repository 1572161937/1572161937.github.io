<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法期中复习</title>
    <url>/2023/04/14/%E7%AE%97%E6%B3%95%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="lecture1"><a href="#lecture1" class="headerlink" title="lecture1"></a>lecture1</h2><h3 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h3><p>正常竖式乘法的复杂度是$O(n^2)$</p>
<p>分治：$[x_1x_2…x_n]&#x3D;[x_1x_2…x_{n&#x2F;2}]\times 10^{n&#x2F;2}+[x_{n&#x2F;2+1}x_{n&#x2F;2+2}…x_n]$</p>
<p>$x\times y&#x3D;(a\times 10^{n&#x2F;2}+b)(c\times 10^{n&#x2F;2}+d)&#x3D;ac\times 10^n+(ad+cb)\times10^{n&#x2F;2}+bd$</p>
<p>两个$n$位数乘法分治成四个$\frac{n}{2}$位数乘法，复杂度仍是$4^{\log_2n}&#x3D;n^{\log_24}&#x3D;n^2$，每次分治还有三次加法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Multiply(x,y,n):</span><br><span class="line">  if n==1:</span><br><span class="line">    return x*y</span><br><span class="line">    </span><br><span class="line">  a = x/pow(10,n/2)</span><br><span class="line">  b = x%pow(10,n/2)</span><br><span class="line">  c = y/pow(10,n/2)</span><br><span class="line">  d = y%pow(10,n/2)</span><br><span class="line">  </span><br><span class="line">  ac = Multiply(a,c,n/2)</span><br><span class="line">  ad = Multiply(a,d,n/2)</span><br><span class="line">  cb = Multiply(c,b,n/2)</span><br><span class="line">  bd = Multiply(b,d,n/2)</span><br><span class="line">  </span><br><span class="line">  xy = ac*pow(10,n)+(ad+cb)*pow(10,n/2)+bd</span><br><span class="line">  return xy</span><br></pre></td></tr></table></figure></div>

<h3 id="Karatsuba乘法"><a href="#Karatsuba乘法" class="headerlink" title="Karatsuba乘法"></a>Karatsuba乘法</h3><p>两个$n$位数乘法分治成三个$\frac{n}{2}$位数乘法，复杂度变为$3^{\log_2n}&#x3D;n^{\log_23}≈n^{1.6}$，有所改善</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Multiply(x,y,n):</span><br><span class="line">  if n==1:</span><br><span class="line">    return x*y</span><br><span class="line">    </span><br><span class="line">  a = x/pow(10,n/2)</span><br><span class="line">  b = x%pow(10,n/2)</span><br><span class="line">  c = y/pow(10,n/2)</span><br><span class="line">  d = y%pow(10,n/2)</span><br><span class="line"></span><br><span class="line">  ac = Multiply(a,c,n/2)</span><br><span class="line">  bd = Multiply(b,d,n/2)</span><br><span class="line">  z = Multiply(a+b,c+d,n/2)</span><br><span class="line"></span><br><span class="line">  xy = ac*pow(10,n)+(z-ac-bd)*pow(10,n/2)+b</span><br><span class="line">  return xy</span><br></pre></td></tr></table></figure></div>

<p>将$n$位数乘法分治成五个$\frac{n}{3}$位数乘法，复杂度$O(n^{1.465})$</p>
<p>经过学者不断改进，达到了$O(n\log n)$</p>
<h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><ul>
<li>两个乘数长度不同：在短的那个数的前⾯补0</li>
<li>n不是偶数：前⼀半n&#x2F;2向下取整，后⼀半n&#x2F;2向上取整</li>
<li>计算与$10^n$相乘：后面补n个0</li>
</ul>
<h3 id="InsertionSort算法"><a href="#InsertionSort算法" class="headerlink" title="InsertionSort算法"></a>InsertionSort算法</h3><p>$O(n^2)$</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">InsertionSort</span>(<span class="params">A</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">        current = A[i]</span><br><span class="line">        j = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; current:</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        A[j+<span class="number">1</span>] = current</span><br></pre></td></tr></table></figure></div>

<h3 id="算法复杂度渐进性分析"><a href="#算法复杂度渐进性分析" class="headerlink" title="算法复杂度渐进性分析"></a>算法复杂度渐进性分析</h3><h4 id="O-…-表示上界"><a href="#O-…-表示上界" class="headerlink" title="$O(…)$表示上界"></a>$O(…)$表示上界</h4><p>$T(n)&#x3D;O(g(n))$等价于</p>
<p>存在$c,n_0&gt;0$，使得任意$n\geq n_0$，都有$T(n)\leq c·g(n)$</p>
<h4 id="Omega-…-表示下界"><a href="#Omega-…-表示下界" class="headerlink" title="$\Omega(…)$表示下界"></a>$\Omega(…)$表示下界</h4><p>$T(n)&#x3D;\Omega(g(n))$等价于</p>
<p>存在$c,n_0&gt;0$，使得任意$n\geq n_0$，都有$T(n)\geq c·g(n)$</p>
<h4 id="Theta-…-表示上界和下界"><a href="#Theta-…-表示上界和下界" class="headerlink" title="$\Theta(…)$表示上界和下界"></a>$\Theta(…)$表示上界和下界</h4><p>$T(n)&#x3D;\Theta(g(n))$等价于</p>
<p>$T(n)&#x3D;O(g(n))$且$T(n)&#x3D;\Omega(g(n))$</p>
<h4 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h4><ul>
<li>证明$T(n) &#x3D; O(g(n))$：提出$c$和$n_0$满足定义。</li>
</ul>
<p>证明:$p(n)&#x3D;a_0+a_1n+a_2n^2+…+a_kn^k&#x3D;O(n^k)$</p>
<p>令$n_0&#x3D;1,c&#x3D;|a_0|+|a_1|+…+|a_k|$</p>
<p>则对于任意$n\geq n_0$，$p(n)\leq|p(n)|\leq |a_0|+|a_1|n+|a_2|n^2+…+|a_k|n^k\leq |a_0|n^k+|a_1|n^k+|a_2|n^k+…+|a_k|n^k&#x3D;c·n^k$</p>
<ul>
<li>证明$T(n)$不是$O(g(n))$，反证法：假设存在一个$c$和一个$n_0$满足定义，通过推导出一个矛盾来证明。</li>
</ul>
<p>证明:对任意$k\geq1$，$n^k$不是$O(n^{k-1})$</p>
<p>假设$n^k$是$O(n^{k-1})$，则存在$c,n_0&gt;0$，使得对任意$n\geq n_0$，都有$n^k\leq c·n^{k-1}$</p>
<p>则对任意$n\geq n_0$，都有$n\leq c$，当$n&#x3D;n_0+c+1$时显然不成立，产生矛盾。</p>
<ul>
<li>对于$f(n),g(n)$，既没有$f(n)&#x3D;O(g(n))$，也没有$f(n)&#x3D;\Omega(g(n))$。</li>
</ul>
<p>只要保证随着$n$的增大，$f(n)$和$g(n)$之间的关系忽大忽小即可。</p>
<h4 id="算法分析的三个指导原则"><a href="#算法分析的三个指导原则" class="headerlink" title="算法分析的三个指导原则"></a>算法分析的三个指导原则</h4><ol>
<li>最坏情况分析</li>
<li>忽略常数因子和低阶项</li>
<li>渐进分析</li>
</ol>
<h2 id="lecture2"><a href="#lecture2" class="headerlink" title="lecture2"></a>lecture2</h2><h3 id="Mergesort归并排序"><a href="#Mergesort归并排序" class="headerlink" title="Mergesort归并排序"></a>Mergesort归并排序</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MergeSort(A):</span><br><span class="line">    n = length(A)</span><br><span class="line">    if(n &lt;= 1)</span><br><span class="line">        return A</span><br><span class="line">    L = MergeSort(A[0:n/2])</span><br><span class="line">    R = MergeSort(A[n/2:n])</span><br><span class="line">    return Merge(L,R)</span><br><span class="line"></span><br><span class="line">Merge(L,R):</span><br><span class="line">    n = length(L) + length(R)</span><br><span class="line">    A[n], i = 0, j = 0</span><br><span class="line">    for k in range(0,n):</span><br><span class="line">        if L[i] &lt; R[j]:</span><br><span class="line">            A[k] = L[i], i = i + 1  </span><br><span class="line">        else:</span><br><span class="line">            A[k] = R[j], j = j + 1     </span><br><span class="line">    return A</span><br></pre></td></tr></table></figure></div>

<h4 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h4><p>$O(n\log n)$</p>
<p>每层$O(n)$步，一共$\log n+1$层</p>
<p>渐进地比InsertionSort的$O(n^2)$好</p>
<h4 id="逆序对数"><a href="#逆序对数" class="headerlink" title="逆序对数"></a>逆序对数</h4><p>站在MergeSort的肩膀上，在MergeSort的Merge过程中，同时进行排序和数逆序对。</p>
<p>对左右两个已经排序的数组进行Merge时，右侧每个数字被放入合并数组时，左侧剩余的数字个数，即是与此数字构成的分离逆序对数量。</p>
<p>$T(n) &#x3D;2T(n&#x2F;2) +O(n)$，复杂度$O(n\log n)$</p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>$$<br>T(n)&#x3D;a·T(\frac{n}{b})+O(n^d)\<br>T(n)&#x3D;<br>\begin{cases}<br>O(n^d\log n)&amp;a&#x3D;b^d\<br>O(n^d)&amp;a&lt;b^d\<br>O(n^{\log_ba})&amp;a&gt;b^d\<br>\end{cases}<br>$$</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>$$<br>T(n)&#x3D;a·T(\frac{n}{b})+c·n^d\<br>Total\ work&#x3D;\sum_{t&#x3D;0}^{log_bn}a^t·c·(\frac{n}{b^t})^d&#x3D;c·n^d·\sum_{t&#x3D;0}^{log_bn}(\frac{a}{b^d})^t\<br>\sum_{t&#x3D;0}^{log_bn}(\frac{a}{b^d})^t&#x3D;<br>\large<br>\begin{cases}<br>1\times(\log n+1)&#x3D;\log n+1&amp;a&#x3D;b^d\<br>1&amp;a&lt;b^d\<br>(\frac{a}{b^d})^{\log_bn}&#x3D;\frac{a^{\log_bn}}{b^{d\log_bn}}&#x3D;\frac{n^{\log_ba}}{n^d}&amp;a&gt;b^d\<br>\end{cases}\\<br>\large<br>T(n)&#x3D;c·n^d·\sum_{t&#x3D;0}^{log_bn}(\frac{a}{b^d})^t&#x3D;<br>\begin{cases}<br>c·n^d·(\log n+1)&#x3D;O(n^d\log n)&amp;a&#x3D;b^d(二者平衡)\<br>c·n^d·1&#x3D;O(n^d)&amp;a&lt;b^d(顶层工作量大)\<br>c·n^d·\frac{n^{\log_ba}}{n^d}&#x3D;O(n^{\log_ba})&amp;a&gt;b^d(底层工作量大)\<br>\end{cases}<br>$$</p>
<h3 id="替换法"><a href="#替换法" class="headerlink" title="替换法"></a>替换法</h3><ul>
<li>对正确答案进行猜测。</li>
<li>试着证明你的猜测是正确的。<ul>
<li>若$T(n)$的表达式中无$O(g(n))$，直接对$T(n)$表达式进行归纳假设</li>
<li>若$T(n)$的表达式中有$O(g(n))$，利用$T(n)\leq C·g(n)$进行归纳假设，找到适合的常数$C$，替换不等式中的$C$后，再进行正式证明。</li>
</ul>
</li>
<li>得到复杂性结果。</li>
</ul>
<h2 id="lecture3"><a href="#lecture3" class="headerlink" title="lecture3"></a>lecture3</h2><h3 id="替换法可能遇到的问题"><a href="#替换法可能遇到的问题" class="headerlink" title="替换法可能遇到的问题"></a>替换法可能遇到的问题</h3><ul>
<li>找不到合适的$C$，可能是前面的假设错误了</li>
<li>若$T(n)$的递归表达式中含有常数，如$T(n)&#x3D;aT(\frac{n}{b})+c$，则可以调整假设的不等式为$T(n)\leq C·g(n)-c$，解决常数部分带来的影响</li>
</ul>
<p>当主定理不起作用时，替换法可以起作用</p>
<h3 id="k-select"><a href="#k-select" class="headerlink" title="k-select"></a>k-select</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select(A,k):</span><br><span class="line">    If len(A) &lt;= 50:</span><br><span class="line">        A = MergeSort(A)</span><br><span class="line">        Return A[k-1] </span><br><span class="line">    p = getPivot(A) // return some pivot </span><br><span class="line">    L, pivotVal, R = Partition(A,p) // split up A to L,A[p],R</span><br><span class="line">    if len(L) == k-1:</span><br><span class="line">        return pivotVal</span><br><span class="line">    else if len(L) &gt; k-1:</span><br><span class="line">        return Select(L, k)</span><br><span class="line">    else if len(L) &lt; k-1:</span><br><span class="line">        return Select(R, k – len(L) – 1)</span><br></pre></td></tr></table></figure></div>

<p>运行时间受pivot位置的影响<br>$$<br>T(n)&#x3D;<br>\begin{cases}<br>T(len(L))+O(n)&amp;len(L)&gt;k-1\<br>T(len(R))+O(n)&amp;len(L)&lt;k-1\<br>O(n)&amp;len(L)&#x3D;k-1\<br>\end{cases}<br>$$</p>
<h4 id="理想的pivot"><a href="#理想的pivot" class="headerlink" title="理想的pivot"></a>理想的pivot</h4><ul>
<li>基于<code>MergeSort</code>：选取最中间的数当pivot(假设可以选出)，由主定理可证明，时间复杂度为$O(n)$</li>
<li><code>RSelect</code>：在A中均匀随机地选取pivot<ul>
<li>最坏情况下时间复杂度为$\Theta(n^2)$</li>
<li>虽然最坏情况下时间复杂度为$\Theta(n^2)$，但平均性能比基于<code>MergeSort</code>的方法还好</li>
</ul>
</li>
<li><code>DSelect</code>：选取中位数当pivot<ul>
<li>只要这个pivot不要太偏两边即可：$3n&#x2F;10 &lt; len(L) &lt; 7n&#x2F;10$，$3n&#x2F;10 &lt; len(R) &lt; 7n&#x2F;10$</li>
<li>分成$\frac{n}{5}$组，每组5个。先在每组中寻找中位数，再在这$\frac{n}{5}$个中位数中寻找中位数。最终这个中位数即为pivot。$T(n)\leq T(\frac{n}{5})+T(\frac{7n}{10})+O(n)$</li>
</ul>
</li>
</ul>
<h4 id="T-n-leq-T-frac-n-5-T-frac-7n-10-O-n"><a href="#T-n-leq-T-frac-n-5-T-frac-7n-10-O-n" class="headerlink" title="$T(n)\leq T(\frac{n}{5})+T(\frac{7n}{10})+O(n)$"></a>$T(n)\leq T(\frac{n}{5})+T(\frac{7n}{10})+O(n)$</h4><h5 id="替换法证明渐进复杂度"><a href="#替换法证明渐进复杂度" class="headerlink" title="替换法证明渐进复杂度"></a>替换法证明渐进复杂度</h5><p>猜测$T(n)&#x3D;O(n)$</p>
<p>假设$T(n)\leq dn$,有$T(k)\leq T(\frac{k}{5})+T(\frac{7k}{10})+ck\leq \frac{dk}{5}+\frac{7dk}{10}+ck\leq dk$</p>
<p>化简得$\frac{9}{10}d+c\leq d$,$d\geq 10c$.令$d&#x3D;max(1,10c)$即可得证</p>
<h5 id="n-x2F-5-7n-x2F-10-怎么来的"><a href="#n-x2F-5-7n-x2F-10-怎么来的" class="headerlink" title="$n&#x2F;5,7n&#x2F;10$怎么来的"></a>$n&#x2F;5,7n&#x2F;10$怎么来的</h5><ul>
<li>$n&#x2F;5$:子数组个数（5个数一组）</li>
<li>$7n&#x2F;10$:大于pivot的数的最大个数</li>
</ul>
<h5 id="对于m个数一组"><a href="#对于m个数一组" class="headerlink" title="对于m个数一组"></a>对于m个数一组</h5><p>$T(n)\leq T(\frac{n}{m})+T(n-\lceil\frac{m}{2}\rceil·\frac{n}{2m})+O(n)$</p>
<p>例如:</p>
<ul>
<li>$m&#x3D;7$时，$T(n)\leq T(\frac{n}{7})+T(\frac{5n}{7})+O(n)$</li>
<li>$m&#x3D;5$时，$T(n)\leq T(\frac{n}{5})+T(\frac{7n}{10})+O(n)$</li>
<li>$m&#x3D;3$时，$T(n)\leq T(\frac{n}{3})+T(\frac{2n}{3})+O(n)$</li>
</ul>
<h2 id="lecture4"><a href="#lecture4" class="headerlink" title="lecture4"></a>lecture4</h2><h3 id="BogoSort"><a href="#BogoSort" class="headerlink" title="BogoSort"></a>BogoSort</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">BogoSort(A):</span><br><span class="line">    while true:</span><br><span class="line">        随机排列A</span><br><span class="line">        if(A is sorted)</span><br><span class="line">            return A</span><br></pre></td></tr></table></figure></div>

<h4 id="期望时间"><a href="#期望时间" class="headerlink" title="期望时间"></a>期望时间</h4><p>$$<br>E[\ 在长度为n的列表上的运行时间\ ]\&#x3D;E[\ (迭代次数)<em>(每次迭代时间)\ ]\&#x3D;(每次迭代时间)</em> E[\ 迭代次数\ ]\&#x3D;O(n⋅n!)<br>$$</p>
<p>最坏运行时间：INF</p>
<h4 id="关于随机算法"><a href="#关于随机算法" class="headerlink" title="关于随机算法"></a>关于随机算法</h4><ul>
<li><p>期望运行时间：</p>
<ul>
<li>公布随机算法</li>
<li>对抗性输入</li>
<li>自己的随机策略</li>
</ul>
</li>
<li><p>最坏运行时间：</p>
<ul>
<li>公布随机算法</li>
<li>对抗性输入。</li>
<li>对抗性随机策略</li>
</ul>
</li>
</ul>
<h3 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h3><p>期望运行时间$O(n\log n)$，最坏运行时间$O(n^2)$</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">QuickSort(A):</span><br><span class="line">    if len(A) &lt;= 1:</span><br><span class="line">        return</span><br><span class="line">    随机选择pivot</span><br><span class="line">    将A的其余部分分成:</span><br><span class="line">        L (小于pivot)</span><br><span class="line">        R (大于pivot)</span><br><span class="line">    重新排列A为[L, x, R]</span><br><span class="line">    QuickSort(L)</span><br><span class="line">    QuickSort(R)</span><br></pre></td></tr></table></figure></div>

<p>$T(n)&#x3D;T(|L|)+T(|R|)+O(n)$</p>
<ul>
<li><p>选定最中间的数当pivot，即$T(n)&#x3D;2·T(\frac{n-1}{2})+O(n)$，得出$T(n)&#x3D;O(n\log n)$</p>
</li>
<li><p>证明随机的期望运行时间为$O(n\log n)$<br>$$<br>因为\ E[|L|]&#x3D;E[|R|\ ],且E[|L|+|R|]&#x3D;E[|L|]+E[|R|]&#x3D;n-1\所以\ E[|L|]&#x3D;E[|R|]&#x3D;\frac{n-1}{2}<br>$$<br>即<code>选定最中间的数当pivot</code>的情况</p>
</li>
</ul>
<h3 id="QuickSort-vs-MergeSort"><a href="#QuickSort-vs-MergeSort" class="headerlink" title="QuickSort vs MergeSort"></a>QuickSort vs MergeSort</h3><ul>
<li><p><code>QuickSort(随机pivot)</code>：期望$O(n\log n)$，最坏$O(n^2)$</p>
</li>
<li><p><code>MergeSort(选定pivot)</code>：最坏$O(n\log n)$</p>
</li>
</ul>
<h3 id="比较类排序算法复杂度下界"><a href="#比较类排序算法复杂度下界" class="headerlink" title="比较类排序算法复杂度下界"></a>比较类排序算法复杂度下界</h3><p>任何比较类排序算法都至少需要$\Omega(n\log n)$；其他类的可以达到$O(n)$，如计数排序、基数排序</p>
<h4 id="用决策树证明比较类排序算法的下界"><a href="#用决策树证明比较类排序算法的下界" class="headerlink" title="用决策树证明比较类排序算法的下界"></a>用决策树证明比较类排序算法的下界</h4><ul>
<li><p>最好运行时间：至少是从根结点到相应叶结点的路径长度，即决策树的深度$Ω(n\log n)$</p>
</li>
<li><p>最差运行时间：至少是树中最长路径的长度。最长路径至少为$O(\log(n!))$，约为$\Omega( n\log n)$</p>
</li>
</ul>
<h2 id="lecture5"><a href="#lecture5" class="headerlink" title="lecture5"></a>lecture5</h2><h3 id="摊还分析"><a href="#摊还分析" class="headerlink" title="摊还分析"></a>摊还分析</h3><ul>
<li>聚合分析：计算$T(n)$之后除以$n$，计算平均值</li>
<li>记账方法：对廉价的业务征收额外费用，并在以后用于支付昂贵的业务，构造实际费用的上界</li>
<li>势方法：给出一个势函数，表征在每一步中可以做的额外工作量，构造实际成本的一个上界</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>主定理：等分的分治递归算法</li>
<li>替换法：非等分的分治递归算法</li>
<li>Worst Case分析：给出worst case的递推表达式（D-Select）</li>
<li>期望运行时间分析：用统计分析的方法求各期望运行场景，统计期望运行时间（QuickSort）</li>
<li>摊还分析：分析n个连续操作的worst case运行时间，摊算到每个操作上，主要有聚集法，记账法，势能法（栈、二进制计数器、动态表、Hash表、Spray Tree等）</li>
</ul>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>search、insert、delete都是$O(h)$，在平衡的二叉搜索树中为$O(\log n)$</p>
<h4 id="后继"><a href="#后继" class="headerlink" title="后继"></a>后继</h4><ul>
<li>如果右孩子非空，转向右孩子后，不断找左孩子直到叶节点。</li>
<li>如果右孩子为空，则一直向上找，直到当前节点是它父亲的左孩子。</li>
</ul>
<h4 id="前驱"><a href="#前驱" class="headerlink" title="前驱"></a>前驱</h4><ul>
<li>如果左孩子非空，转向左孩子后，不断找右孩子直到叶节点。</li>
<li>如果左孩子为空，则一直向上找，直到当前节点是它父亲的右孩子。</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><code>balance(v)=height(v.right)-height(v.left),balance(v)∈&#123;-1,0-1&#125;</code></p>
<p>$N(h)&#x3D;F_{h+3}-1$</p>
<h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode <span class="title">rotateRight</span><span class="params">(BSTNode p)</span> </span>&#123; <span class="comment">// 往右转</span></span><br><span class="line">    BSTNode q = p.left;</span><br><span class="line">    p.left = q.right;</span><br><span class="line">    q.right = p;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTNode <span class="title">rotateLeft</span><span class="params">(BSTNode p)</span> </span>&#123; <span class="comment">// 往左转</span></span><br><span class="line">    BSTNode q = p.right;</span><br><span class="line">    p.right = q.left;</span><br><span class="line">    q.left = p;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="组合旋转"><a href="#组合旋转" class="headerlink" title="组合旋转"></a>组合旋转</h4><p>rotateLeftRight(p)：先往左转，再往右转</p>
<p>rotateRightLeft(p)：先往右转，再往左传</p>
<h4 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h4><p>由于删除的操作比较复杂，在实际实现的时候，考虑经常是插入较多，删除较少，所以为树中每个节点设置一个alive, dead的标签。</p>
<h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h3><p>部分节点有两个孩子，部分节点可以有三个孩子</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul>
<li><p>如果它是2-node，插入之后变为3-node，没问题。</p>
</li>
<li><p>如果它是3-node，插入后，临时变为4-node，再拆成两个节点，将中间的数提升一层。</p>
</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除后用后继节点替换，再修复维护树的结构（不断merge，最后再adopt）</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>每个结点不是红就是黑</p>
</li>
<li><p>根结点是黑</p>
</li>
<li><p>每个叶结点(NIL)为黑色</p>
</li>
<li><p>如果一个节点是红色的，那么它的两个子节点都是黑色的，即从根到叶的一条简单路径上没有两个连续的红色节点</p>
</li>
<li><p>对于每个节点，从该节点到叶节点的所有路径包含相同数量的黑节点，即黑高度相同。</p>
<ul>
<li>黑高度bh(x):从x到叶子的路径上的黑节点数(包括NIL)，不包括x。</li>
</ul>
</li>
</ul>
<h4 id="树高"><a href="#树高" class="headerlink" title="树高"></a>树高</h4><p>有$n$个内部节点的红黑树高度不超过$2\log(n+1)$<br>$$<br>n\geq2^{bh}-1\geq2^h-1\<br>n+1\geq2^h\<br>h\leq2\log(n+1)<br>$$</p>
<h4 id="插入删除太难了"><a href="#插入删除太难了" class="headerlink" title="插入删除太难了"></a>插入删除太难了</h4><h2 id="lecture6"><a href="#lecture6" class="headerlink" title="lecture6"></a>lecture6</h2><h3 id="Range-Tree"><a href="#Range-Tree" class="headerlink" title="Range Tree"></a>Range Tree</h3><h4 id="1D-Range-Search"><a href="#1D-Range-Search" class="headerlink" title="1D Range Search"></a>1D Range Search</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rsearch</span><span class="params">(TreeNode root, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; l) &#123;</span><br><span class="line">        <span class="built_in">rsearch</span>(root.left, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt;= l &amp;&amp; root.val &lt;= r) &#123;</span><br><span class="line">        results.<span class="built_in">add</span>(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; r) &#123;</span><br><span class="line">        <span class="built_in">rsearch</span>(root.right, l, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>2D Range Tree</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">BuildTree(S):</span><br><span class="line">    if |S|==1:</span><br><span class="line">        return 叶节点t</span><br><span class="line">    选出按X排序的中位数x</span><br><span class="line">    小于x的部分为L,大于x的部分为R</span><br><span class="line">    t.val = x</span><br><span class="line">    t.left = BuildTree(L)</span><br><span class="line">    t.right = BuildTree(R)</span><br><span class="line">    t.ytree = MergeYTree(t.left.ytree,t.right.ytree)</span><br><span class="line">    return 节点t</span><br></pre></td></tr></table></figure></div>

<p>空间$O(n\log n)$，建树时间$O(n\log n)$</p>
<p>2D搜索：先1D搜索x。如果x满足区间，则在对应的ytree里1D搜索y；否则继续1D搜索x。</p>
<p>KD：搜索时间$O(k+\log^dn)$，空间$O(n\log^{d-1}n)$</p>
<h3 id="K-D-Tree"><a href="#K-D-Tree" class="headerlink" title="K-D Tree"></a>K-D Tree</h3><p>一层按x分割，一层按y分割，均选取中位数作为分割点</p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>直接插入至叶节点即可</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><ul>
<li><p>如果当前节点包含待删除的点</p>
<ul>
<li>如果是叶节点，直接删除即可</li>
<li>如果不是叶节点<ul>
<li>如果有右孩子，则在右侧子树中查找当前节点维度的最小值。用找到的最小值替换节点。</li>
<li>如果没有右孩子，则在左侧子树中查找当前节点维度的最小值。用找到的最小值替换节点，并递归地删除左子树中的最小值。将新的左子树作为当前节点的右子树。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果当前节点不是要删除的点</p>
<ul>
<li>如果要删除的节点在当前维度上小于当前节点，则递归左子树。</li>
<li>否则递归右子树。</li>
</ul>
</li>
</ul>
<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Query(t,r):  // r:query range</span><br><span class="line">    if t是叶节点:</span><br><span class="line">        return t</span><br><span class="line">    if t.range 包含在r内:</span><br><span class="line">        子树中的点全部加入答案</span><br><span class="line">    else if t.range 与r相交:</span><br><span class="line">        Query(t.left,r)</span><br><span class="line">        Query(t.right,r)</span><br></pre></td></tr></table></figure></div>

<p>查询时间$O(\sqrt n)$</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">d维</th>
<th align="center">KD Tree</th>
<th align="center">Range Tree</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排序</td>
<td align="center">$O(dn\log n)$</td>
<td align="center">$O(dn\log n)$</td>
</tr>
<tr>
<td align="center">空间</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n\log^{d-1}n)$</td>
</tr>
<tr>
<td align="center">查询时间</td>
<td align="center">$O(n^{1-\frac{1}{d}}+k)$</td>
<td align="center">$O(\log^dn+k)$</td>
</tr>
</tbody></table>
<h2 id="lecture7"><a href="#lecture7" class="headerlink" title="lecture7"></a>lecture7</h2><h3 id="Quad-Tree"><a href="#Quad-Tree" class="headerlink" title="Quad Tree"></a>Quad Tree</h3><ul>
<li><p>每个内部节点最多有四个子节点。</p>
</li>
<li><p>四叉树中的每个节点都对应一个正方形。</p>
</li>
<li><p>节点v的子节点对应于正方形v的四个象限。</p>
</li>
<li><p>节点的子节点被标记为NE, NW, SW和SE，以指示它们对应于哪个象限</p>
</li>
</ul>
<h3 id="最近邻搜索-in-Quad-Tree"><a href="#最近邻搜索-in-Quad-Tree" class="headerlink" title="最近邻搜索 in Quad Tree"></a>最近邻搜索 in Quad Tree</h3><ul>
<li><p>初始化一个大圆r</p>
</li>
<li><p>将根节点压入栈中</p>
</li>
<li><p>不断重复：</p>
<ul>
<li><p>从栈中pop出来T</p>
</li>
<li><p>对于T的每一个孩子C：</p>
<p>如果C与r相交，就把C压栈</p>
<p>如果C是叶子，检验C中的点，更新r</p>
</li>
</ul>
</li>
<li><p>问题：</p>
<ul>
<li>四叉树可能有很多空的节点</li>
<li>如果点比较稀疏，那么需要很长的时间才能找到最近邻。</li>
</ul>
</li>
</ul>
<h3 id="最近邻搜索-in-K-D-Tree"><a href="#最近邻搜索-in-K-D-Tree" class="headerlink" title="最近邻搜索 in K-D Tree"></a>最近邻搜索 in K-D Tree</h3><ul>
<li><p>遍历整棵树</p>
</li>
<li><p>保留一个目前为止找到最近的点C。当子树的边界框不包含任何距离C更近的点时，剪枝。</p>
</li>
<li><p>从包含Q的子树开始回溯，然后递归地检查可能包含更接近Q的点的子树。</p>
</li>
</ul>
<p>在大多数情况下，运行时间更接近于$O(2^d+\log n)$</p>
<p>其中$2^d$为访问在查询点附近的一些节点集，$\log n$为查找这些节点</p>
<h3 id="k近邻搜索KNN"><a href="#k近邻搜索KNN" class="headerlink" title="k近邻搜索KNN"></a>k近邻搜索KNN</h3><ul>
<li><p>通过保持$k$个当前最佳值来找到一个查询的$k$个最近邻居。</p>
</li>
<li><p>分支只有在不能有比$k$个当前最佳值更近的点时才会被剪枝。</p>
</li>
<li><p>复杂度为$O(k(2^d+\log n))$，当d较大时不适合。当d是一个常数时，它是$O(k\log n)$</p>
</li>
<li><p>区域查询的复杂度为$O(n^{1-1&#x2F;d}+ k)$</p>
</li>
</ul>
<h3 id="PCP-Tree"><a href="#PCP-Tree" class="headerlink" title="PCP Tree"></a>PCP Tree</h3><ul>
<li><p>分裂的方向可以不是x和y。</p>
</li>
<li><p>将垂直于最宽分布轴的点分开。</p>
</li>
<li><p>主成分划分（PCP）</p>
</li>
</ul>
<h3 id="近似最近邻ANN"><a href="#近似最近邻ANN" class="headerlink" title="近似最近邻ANN"></a>近似最近邻ANN</h3><ul>
<li>仅检查K-D Tree中最接近的N个bin</li>
<li>使用优先级队列按其与查询的距离顺序排列bin。</li>
<li>返回高概率的最近邻居(例如95%)</li>
</ul>
<p>Best Bin First(BBF)：查询点首先查找包含它的Bin，然后查找相邻的Bin，而不是在树中最近的邻居。会快很多</p>
<h3 id="ε-ANN"><a href="#ε-ANN" class="headerlink" title="ε-ANN"></a>ε-ANN</h3><p>查找具有高概率的最近邻，即查找P中的点p’，其到q的距离至多是真实最近距离R的(1+ε)倍。使得高维空间的查找更高效。</p>
<h3 id="局部敏感哈希"><a href="#局部敏感哈希" class="headerlink" title="局部敏感哈希"></a>局部敏感哈希</h3><p>构造了一组位置敏感的哈希函数，使得在哈希函数转换后，附近点接近的概率大于两个遥远点在同一转换后接近的概率。</p>
<h3 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h3><ul>
<li><p>想法：找到一个映射T来降低数据的维数。</p>
</li>
<li><p>缺点：可能无法找到所有相似的对象(即，距离关系可能无法保存)</p>
</li>
</ul>
<h3 id="K-D-Tree总结"><a href="#K-D-Tree总结" class="headerlink" title="K-D Tree总结"></a>K-D Tree总结</h3><ul>
<li><p>使用条件：适用于低维海量数据点。</p>
<ul>
<li>$n&gt;&gt;2^d$，二维坐标、三维坐标的云处理</li>
</ul>
</li>
<li><p>d较大时需要近似最近邻，找到k个最近的</p>
</li>
</ul>
<h2 id="lecture8"><a href="#lecture8" class="headerlink" title="lecture8"></a>lecture8</h2><h3 id="层次聚类树"><a href="#层次聚类树" class="headerlink" title="层次聚类树"></a>层次聚类树</h3><p>空间：$O(n\log_dn)$</p>
<p>建树：$O(nTd\log_dn)$</p>
<p>k-NN：$O(kd\log_dn)$</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ul>
<li><p>可以再先mod q，再mod m，会更加随机</p>
<ul>
<li>除法散列：$h(x)&#x3D;x\ mod\ m$</li>
<li>乘法散列：$h(x)&#x3D;(ax)\ mod\ m$</li>
<li>线性散列：$h(x)&#x3D;(ax+b)\ mod\ m$</li>
</ul>
</li>
<li><p>常见哈希：多项式哈希</p>
</li>
</ul>
]]></content>
  </entry>
</search>
